#!/bin/bash

#
# Script to configure an iptables based firewall using template from Ansible playbook role.
#
# This file must be located in /etc/firewall.bash
#
# Common port reference:
#   22: SSH
#   25: SMTP
#   80: HTTP
#   123: NTP
#   443: HTTPS

#
# Bash sanity.
#
set -u

#
# Hosts and interfaces.
#
TARGET_SERVER='{{ ansible_hostname }}'
declare -a INTERNAL_INTERFACES=(
{% for internal_interface in internal_interfaces %}
	'{{ internal_interface.device }}',	# {{ internal_interface.description }}
{% endfor %}
)
declare -a EXTERNAL_INTERFACES=(
{% for external_interface in external_interfaces %}
	'{{ external_interface.device }}',	# {{ external_interface.description }}
{% endfor %}
)

#
# Network addresses and ranges.
#
LOOPBACK='127.0.0.0/8'



#
##
### Main.
##
#

#
# Get (short) name of the server where this script is executed.
#  * Ignore the domain.
#  * Remove any -mgmt suffixes
#
SERVER_NAME="$(hostname -s)"
SERVER_NAME="$(echo ${SERVER_NAME} | sed 's/-mgmt//')"

#
# Check if we have a config valid for this server.
#
if [[ "${SERVER_NAME}" == "${TARGET_SERVER}" ]]; then
	echo "INFO: Hostname check passed. Will configure firewall..."
else
	echo "ERROR: This config file is for \"${TARGET_SERVER}\", but this is \"${SERVER_NAME}\"."
	echo 'FATAL: Cannot configure firewall on this server.'
	exit 1
fi

#
##
### Kernel tweaks.
##
#

#
# Prevent SYNC-floods.
#
echo '1' > /proc/sys/net/ipv4/tcp_syncookies # confusing name, but applies to IP version 6 as well.

#
# Limit response to ICMP packets.
#
echo '1' > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
echo '1' > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses

#
# Disable redirects and forwarding, which are only required on routers.
#
echo '0' > /proc/sys/net/ipv4/conf/all/accept_redirects
echo '0' > /proc/sys/net/ipv6/conf/all/accept_redirects
echo '0' > /proc/sys/net/ipv4/conf/all/forwarding
echo '0' > /proc/sys/net/ipv6/conf/all/forwarding

#
# Disable logging of spoofed packets, source routed packets, and redirect packets
# to prevent flooding the logs.
#
echo '0' > /proc/sys/net/ipv4/conf/all/log_martians

#
# Disable source routed packets, which should only be required for debugging network issues.
#
echo '0' > /proc/sys/net/ipv4/conf/all/accept_source_route
echo '0' > /proc/sys/net/ipv6/conf/all/accept_source_route

#
# Enable IP spoofing protection.
#
echo '1' > /proc/sys/net/ipv4/conf/all/rp_filter

#
##
### IPv6: disable all and log.
##
#

#
# Flush and delete existing rules.
#
ip6tables -F
ip6tables -X

#
# Set the default policies to drop everything.
#
ip6tables -P INPUT DROP
ip6tables -P OUTPUT DROP
ip6tables -P FORWARD DROP

#
# We must accept IPv6 traffic on the loopback interface to prevent tests from failing
# during installation of verious software packages with network functionality.
#
ip6tables -A INPUT  -i lo -j ACCEPT
ip6tables -A OUTPUT -o lo -j ACCEPT

#
##
### IPv4.
##
#

#
# Initialize and flush everything to start with a clean slate.
#
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -t raw -F
iptables -t raw -X
iptables -t security -F
iptables -t security -X
iptables -Z

#
# Create custom chain for LOGDROP.
#
iptables -N LOGDROP
iptables -A LOGDROP -m limit --limit 15/minute -j LOG --log-level 7 --log-prefix 'Dropped by iptables firewall: '
iptables -A LOGDROP -j DROP

#
# Config default policies to drop.
#
# Log EVERYTHING (ONLY for Debug).
# iptables -A INPUT -j LOG
{% if iptables_log_dropped_packets %}
iptables -P INPUT   LOGDROP
{% else %}
iptables -P INPUT   DROP
{% endif %}
iptables -P OUTPUT  DROP
iptables -P FORWARD DROP

#
# Refuse loopback packets incoming from external interface.
#
for EXT_INTERFACE in "${EXTERNAL_INTERFACES[@]}"; do
	iptables -A INPUT -i "${EXT_INTERFACE}" -d "${LOOPBACK}" -j DROP
done

#
# Allow loopback.
#
iptables -A INPUT  -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

#
# Allow anything over internal interfaces.
#
for INT_INTERFACE in "${INTERNAL_INTERFACES[@]}"; do
	iptables -A INPUT  -i "${INT_INTERFACE}" -j ACCEPT
	iptables -A OUTPUT -o "${INT_INTERFACE}" -j ACCEPT
done

###############################################################################################################################################



# Forwarded ports.
{# Add a rule for each forwarded port #}
{% for forwarded_port in iptables_forwarded_tcp_ports %}
iptables -t nat -I PREROUTING -p tcp --dport {{ forwarded_port.src }} -j REDIRECT --to-port {{ forwarded_port.dest }}
iptables -t nat -I OUTPUT -p tcp -o lo --dport {{ forwarded_port.src }} -j REDIRECT --to-port {{ forwarded_port.dest }}
{% endfor %}
{% for forwarded_port in iptables_forwarded_udp_ports %}
iptables -t nat -I PREROUTING -p udp --dport {{ forwarded_port.src }} -j REDIRECT --to-port {{ forwarded_port.dest }}
iptables -t nat -I OUTPUT -p udp -o lo --dport {{ forwarded_port.src }} -j REDIRECT --to-port {{ forwarded_port.dest }}
{% endfor %}

# Open ports.
{# Add a rule for each open port #}
{% for port in iptables_allowed_tcp_ports %}
iptables -A INPUT -p tcp -m tcp --dport {{ port }} -j ACCEPT
{% endfor %}
{% for port in iptables_allowed_udp_ports %}
iptables -A INPUT -p udp -m udp --dport {{ port }} -j ACCEPT
{% endfor %}

# Accept icmp ping requests.
iptables -A INPUT -p icmp -j ACCEPT

# Allow NTP traffic for time synchronization.
iptables -A OUTPUT -p udp --dport 123 -j ACCEPT
iptables -A INPUT -p udp --sport 123 -j ACCEPT

# Additional custom rules.
{% for rule in iptables_additional_rules %}
{{ rule }}
{% endfor %}

# Allow established connections:
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT




############################################################################################################################3

#
# Allow operator/nagios.
#
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp  -s ${OPERATOR} -j ACCEPT
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp  -d ${OPERATOR} -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p udp  -s ${OPERATOR} -j ACCEPT
iptables -A OUTPUT -o ${INTERFACE_EXT} -p udp  -d ${OPERATOR} -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p icmp -s ${OPERATOR} -j ACCEPT
iptables -A OUTPUT -o ${INTERFACE_EXT} -p icmp -d ${OPERATOR} -j ACCEPT

#
# Allow outbound ICMP.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p icmp -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p icmp -m state --state ESTABLISHED,RELATED     -j ACCEPT

#
# Allow outbound NTP.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p udp --dport 123 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p udp --sport 123 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow outbound SMTP.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp -m multiport --dport 25,587 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp -m multiport --sport 25,587 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow outbound DNS.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p udp --dport 53 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p udp --sport 53 -m state --state ESTABLISHED     -j ACCEPT
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp --dport 53 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp --sport 53 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow outbound HTTP.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp --sport 80 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow outbound HTTPS.
#
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp --sport 443 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow SSH inbound and outbound.
#
for IP_ADDRESS in ${ALLOW_SSH_INBOUND[@]}; do
  iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp -s ${IP_ADDRESS} --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
done
for IP_ADDRESS in ${ALLOW_SSH_OUTBOUND[@]}; do
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp -d ${IP_ADDRESS} --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
done
iptables   -A OUTPUT -o ${INTERFACE_EXT} -p tcp                  --sport 22 -m state --state ESTABLISHED     -j ACCEPT
iptables   -A INPUT  -i ${INTERFACE_EXT} -p tcp                  --sport 22 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow MySQL outbound.
#
# Required a.o. for conncections to the public Ensembl databases via the Ensembl Perl API
#
for IP_ADDRESS in ${ALLOW_EBI_MYSQL_OUTBOUND[@]}; do
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp -d ${IP_ADDRESS} -m multiport --dports 3306,5306,5316 -m state --state NEW,ESTABLISHED -j ACCEPT
done
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp                    -m multiport --sports 3306,5306,5316 -m state --state ESTABLISHED     -j ACCEPT

#
# Allow FTP outbound.
#
# We need a default and an additional connection tracking kernel module 
# in order to track FTP connections and know what is a RELATED connection.
# The extra module must be added to /etc/sysconfig/iptables-config
#    IPTABLES_MODULES="nf_conntrack_ftp"
#
/sbin/modprobe nf_conntrack     # Default module: should already be present, just checking here.
/sbin/modprobe nf_conntrack_ftp # Extra module: should be added to /etc/sysconfig/iptables-config, just checking here.
#
# Firstly, allow FTP control initiated by the client.
#
for IP_ADDRESS in ${ALLOW_FTP_OUTBOUND[@]}; do
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp -d ${IP_ADDRESS} --dport 21 -m state --state NEW,ESTABLISHED -j ACCEPT
done
iptables   -A INPUT  -i ${INTERFACE_EXT} -p tcp                  --sport 21 -m state --state ESTABLISHED     -j ACCEPT
#
# Secondly, allow FTP data connections.
#  * For Active Mode FTP the client must accept RELATED connections from the server on port 20 
#    to the client on a port number negotiated in the FTP control connection.
#  * For Passive Mode FTP the client starts a RELATED connection from a random own high port number 
#    to the server's fixed high port number negotiated in the FTP control connection.
#  * For both Active and Passive Mode FTP, the nf_conntrack_ftp kernel module is required at the FTP client 
#    to pick up the negotiated port number from the FTP control packet payloads.
#
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp --sport 20                  -m state --state ESTABLISHED,RELATED -j ACCEPT # Active Mode
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp --dport 20                  -m state --state ESTABLISHED         -j ACCEPT # Active Mode
iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp --sport 1024: --dport 1024: -m state --state RELATED,ESTABLISHED -j ACCEPT # Passive Mode
iptables -A INPUT  -i ${INTERFACE_EXT} -p tcp --sport 1024: --dport 1024: -m state --state ESTABLISHED         -j ACCEPT # Passive Mode

#
# Allow Aspera outbound.
#
# Aspera requires (most common configs):
#  * SSH on either TCP port 22 or TCP 33001 for control and
#  * Data stream on at least UDP port 33001.
#    In case the server OS doesn't allow UDP port sharing a range of UDP ports is used
#    where the number of ports determines the max number of concurrent connections/clients.
#
for IP_ADDRESS in ${ALLOW_ASPERA_OUTBOUND[@]}; do
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p tcp -d ${IP_ADDRESS} -m multiport --dports 22,33001    -m state --state NEW,ESTABLISHED -j ACCEPT
  iptables -A OUTPUT -o ${INTERFACE_EXT} -p udp -d ${IP_ADDRESS} -m multiport --dports 33001:33100 -m state --state NEW,ESTABLISHED -j ACCEPT
done
iptables   -A INPUT  -i ${INTERFACE_EXT} -p tcp                  -m multiport --sports 22,33001    -m state --state ESTABLISHED     -j ACCEPT
iptables   -A INPUT  -i ${INTERFACE_EXT} -p udp                  -m multiport --sports 33001:33100 -m state --state ESTABLISHED     -j ACCEPT

#
# Log incoming packets, but only from RUGNET, 
# because we can act upon misbehaving clients from RUG, but not from elsewhere.
#
iptables -A INPUT -i ${INTERFACE_EXT} -s 129.125.0.0/16 -j LOGDROP

#
# (Re)start fail2ban, so it will (re)create a custom f2b-SSH iptables chain.
#
service fail2ban restart

#
# List the rules:
#
echo '#'
echo '##'
echo '### iptables --list -n ###'
echo '##'
echo '#'
iptables --list -n
echo '#'
echo '##'
echo '### ip6tables --list -n ###'
echo '##'
echo '#'
ip6tables --list -n

#
# Save config for next boot.
#
service iptables save
service ip6tables save


